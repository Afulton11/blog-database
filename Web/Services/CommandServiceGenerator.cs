using DataAccess.DataAccess.CommandServices;
using DataAccess.QueryServices;
using DatabaseFactory.Data.Contracts;
using Domain.Business.CommandServices;
using Domain.Data.Commands;
using EnsureThat;
using SimpleInjector;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Web.Services
{
    public static class CommandServiceGenerator
    {

        public static void RegisterCommandServices(this Container container)
        {
            EnsureArg.IsNotNull(container, nameof(container));

            var queryAssemblies = new[]
            {
                typeof(ICommand).Assembly
            };

            var commandTypes = container.GetTypesToRegister(
                typeof(ICommand),
                queryAssemblies);

            foreach (var type in commandTypes)
            {
                RegisterCommandService(container, type);
            }
        }

        private static void RegisterCommandService(Container container, Type commandType)
        {
            var commandServiceType = typeof(ICommandService<>).MakeGenericType(commandType);
            var commandServiceImplType = typeof(AutoGeneratedCommandService<>).MakeGenericType(commandType);

            try
            {
                container.RegisterSingleton(commandServiceType, () =>
                    CreateCommandServiceInstance(
                        container,
                        commandType,
                        commandServiceImplType));

            }
            catch
            {
                Console.WriteLine($"{commandType.ToFriendlyName()} should have its own custom service!");
            }
        }

        private static dynamic CreateCommandServiceInstance(Container container, Type commandType, Type commandServiceImplType)
        {
            const string SCHEMA_NAME = "Blog";

            var commandParameters = GetCreateCommandParametersFunc(commandType);
            var procedureName = commandType.Name.Replace("Command", "");
            var fullProcedureName = SCHEMA_NAME + "." + procedureName;

            var database = container.GetInstance<IDatabase>();

            return Activator.CreateInstance(commandServiceImplType, database, commandParameters, fullProcedureName);
        }
      
        private static Func<dynamic, IDictionary<string, object>> GetCreateCommandParametersFunc(Type type)
        {
            return i => type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .SelectMany<PropertyInfo, KeyValuePair<string, object>>(p => CommandPropertySelector(i, p))
                .ToDictionary(property => property.Key, property => property.Value);
        }

        private static IEnumerable<KeyValuePair<string, object>> CommandPropertySelector(dynamic instance, PropertyInfo propertyInfo)
        {
            if (propertyInfo.PropertyType.IsClass && !propertyInfo.PropertyType.Namespace.StartsWith("System"))
            {
                var propertyInstance = propertyInfo.GetValue(instance);
                var members = propertyInfo.PropertyType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

                foreach (var member in members)
                {
                    var selectedMembers = CommandPropertySelector(propertyInstance, member);
                    
                    foreach (KeyValuePair<string, object> selectedMember in selectedMembers)
                    {
                        yield return selectedMember;
                    }
                }
            }
            else
            {
                yield return CreateQueryParameter(propertyInfo.Name, propertyInfo.GetValue(instance));
            }
        }

        private static KeyValuePair<string, object> CreateQueryParameter(string argumentName, object value)
        {
            if (value is bool boolValue)
            {
                value = boolValue ? 1 : 0;
            }
            return new KeyValuePair<string, object>($"@{argumentName}", value);
        }
    }
}
